use kube::{CustomResource, CustomResourceExt, client::Client, Api, api::PatchParams, api::Patch};
use k8s_openapi::apiextensions_apiserver::pkg::apis::apiextensions::v1::CustomResourceDefinition;
use schemars::JsonSchema;
use serde::{Deserialize, Serialize};
//use kube::{client::Client, runtime::controller::Action, runtime::Controller, Api};

pub const RESOURCE_NAME: &str = "nextclouds.sotolitolabs.com";

/// Struct corresponding to the Specification (`spec`) part of the `Echo` resource, directly
/// reflects context of the `nextcloud.yaml` file to be found in this repository.
/// The `Echo` struct will be generated by the `CustomResource` derive macro.
#[derive(CustomResource, Serialize, Deserialize, Debug, PartialEq, Clone, JsonSchema)]
#[kube(
    group = "sotolitolabs.com",
    version = "v1",
    kind = "Nextcloud",
    plural = "nextclouds",
    derive = "PartialEq",
    namespaced
)]
pub struct NextcloudSpec {
    pub replicas: i32,
    pub php_image: String,
}

/// Creates the Nextcloud CRD
/// This helps to avoid the manual creation of the Nextcloud CRD
pub async fn create_crd(client: Client) {
    //let nextclouds = Api::default_namespaced(client.clone());
    let crds: Api<CustomResourceDefinition> = Api::all(client.clone());
    println!("Creating Nextcloud CRD");
    match crds.patch(RESOURCE_NAME,
        &PatchParams::apply("imcsk8-test"),
        &Patch::Apply(Nextcloud::crd())
    ).await {
        Ok(r) => println!("{} CRD created {:?}", RESOURCE_NAME, r),
        Err(e) => println!("Error creating {} CRD {:?}!", RESOURCE_NAME, e),
    };
}
